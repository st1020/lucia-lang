//! Generated by `cargo codegen`, do not edit by hand.

#![allow(non_snake_case)]
use crate::{
    compiler_new::{
        ast::{self, support, AstChildren, AstNode},
        syntax::{
            SyntaxKind::{self, *},
            SyntaxNode, SyntaxToken,
        },
    },
    T,
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Root {
    pub(crate) syntax: SyntaxNode,
}
impl Root {
    #[inline]
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Block {
    pub(crate) syntax: SyntaxNode,
}
impl Block {
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }
    #[inline]
    pub fn stmts(&self) -> AstChildren<Stmt> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStmt {
    pub(crate) syntax: SyntaxNode,
}
impl IfStmt {
    #[inline]
    pub fn if_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![if])
    }
    #[inline]
    pub fn condition(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn then_branch(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn else_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![else])
    }
    #[inline]
    pub fn else_branch(&self) -> Option<ElseBranch> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LoopStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasLoopBody for LoopStmt {}
impl LoopStmt {
    #[inline]
    pub fn loop_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![loop])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasLoopBody for WhileStmt {}
impl WhileStmt {
    #[inline]
    pub fn while_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![while])
    }
    #[inline]
    pub fn condition(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasLoopBody for ForStmt {}
impl ForStmt {
    #[inline]
    pub fn for_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![for])
    }
    #[inline]
    pub fn target(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn in_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![in])
    }
    #[inline]
    pub fn iterable(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStmt {
    pub(crate) syntax: SyntaxNode,
}
impl BreakStmt {
    #[inline]
    pub fn break_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![break])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ContinueStmt {
    #[inline]
    pub fn continue_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![continue])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnStmt {
    #[inline]
    pub fn return_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![return])
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ThrowStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ThrowStmt {
    #[inline]
    pub fn throw_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![throw])
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlobalStmt {
    pub(crate) syntax: SyntaxNode,
}
impl GlobalStmt {
    #[inline]
    pub fn global_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![global])
    }
    #[inline]
    pub fn arguments(&self) -> AstChildren<TypedName> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ImportStmt {
    #[inline]
    pub fn import_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![import])
    }
    #[inline]
    pub fn package_path(&self) -> Option<PackagePath> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn import_kind(&self) -> Option<ImportKind> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnStmt {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for FnStmt {}
impl FnStmt {
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![fn])
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn params(&self) -> AstChildren<Param> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn body(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignStmt {
    #[inline]
    pub fn left(&self) -> Option<AssignLeft> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn right(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignOpStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignOpStmt {
    #[inline]
    pub fn left(&self) -> Option<AssignLeft> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn op(&self) -> Option<AssignOp> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn right(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignUnpackStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignUnpackStmt {
    #[inline]
    pub fn left(&self) -> AstChildren<AssignLeft> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn right(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignMultiStmt {
    pub(crate) syntax: SyntaxNode,
}
impl AssignMultiStmt {
    #[inline]
    pub fn left(&self) -> AstChildren<AssignLeft> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn eq_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![=])
    }
    #[inline]
    pub fn right(&self) -> AstChildren<Expr> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Name {
    pub(crate) syntax: SyntaxNode,
}
impl Name {
    #[inline]
    pub fn ident_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![ident])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypedName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for TypedName {}
impl TypedName {
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PackagePath {
    pub(crate) syntax: SyntaxNode,
}
impl PackagePath {
    #[inline]
    pub fn names(&self) -> AstChildren<Name> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlobImport {
    pub(crate) syntax: SyntaxNode,
}
impl GlobImport {
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![::])
    }
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AliasImport {
    pub(crate) syntax: SyntaxNode,
}
impl AliasImport {
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    #[inline]
    pub fn alias(&self) -> Option<Name> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NestedImport {
    pub(crate) syntax: SyntaxNode,
}
impl NestedImport {
    #[inline]
    pub fn coloncolon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![::])
    }
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }
    #[inline]
    pub fn items(&self) -> AstChildren<ImportItem> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportItem {
    pub(crate) syntax: SyntaxNode,
}
impl ImportItem {
    #[inline]
    pub fn as_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![as])
    }
    #[inline]
    pub fn member_attr_property(&self) -> Option<MemberAttrProperty> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Param {
    pub(crate) syntax: SyntaxNode,
}
impl Param {
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    #[inline]
    pub fn typed_name(&self) -> Option<TypedName> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RetType {
    pub(crate) syntax: SyntaxNode,
}
impl RetType {
    #[inline]
    pub fn ret(&self) -> Option<ReturnType> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn throw(&self) -> Option<ThrowType> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Type {
    pub(crate) syntax: SyntaxNode,
}
impl Type {
    #[inline]
    pub fn atom_types(&self) -> AstChildren<AtomType> {
        support::children(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberItemExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MemberItemExpr {
    #[inline]
    pub fn table(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn kind(&self) -> Option<MemberItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn property(&self) -> Option<MemberItemProperty> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberAttrExpr {
    pub(crate) syntax: SyntaxNode,
}
impl MemberAttrExpr {
    #[inline]
    pub fn table(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn kind(&self) -> Option<MemberAttrKind> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn property(&self) -> Option<MemberAttrProperty> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl BinaryExpr {
    #[inline]
    pub fn op(&self) -> Option<BinaryOp> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn member_item_property(&self) -> Option<MemberItemProperty> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl UnaryExpr {
    #[inline]
    pub fn op(&self) -> Option<UnaryOp> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpr {
    pub(crate) syntax: SyntaxNode,
}
impl CallExpr {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
    #[inline]
    pub fn member_item_property(&self) -> Option<MemberItemProperty> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ParenExpr {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TableExpr {
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }
    #[inline]
    pub fn table_items(&self) -> AstChildren<TableItem> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ListExpr {
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }
    #[inline]
    pub fn list_items(&self) -> AstChildren<ListItem> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnExpr {
    pub(crate) syntax: SyntaxNode,
}
impl FnExpr {
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![fn])
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn params(&self) -> AstChildren<Param> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn body(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClosureExpr {
    pub(crate) syntax: SyntaxNode,
}
impl ClosureExpr {
    #[inline]
    pub fn pipe_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![|])
    }
    #[inline]
    pub fn params(&self) -> AstChildren<Param> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn body(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoExpr {
    pub(crate) syntax: SyntaxNode,
}
impl DoExpr {
    #[inline]
    pub fn do_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![do])
    }
    #[inline]
    pub fn body(&self) -> Option<Block> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryExpr {
    pub(crate) syntax: SyntaxNode,
}
impl TryExpr {
    #[inline]
    pub fn try_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![try])
    }
    #[inline]
    pub fn try_kind(&self) -> Option<TryKind> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn call_expr(&self) -> Option<CallExpr> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralExpr {
    pub(crate) syntax: SyntaxNode,
}
impl LiteralExpr {
    #[inline]
    pub fn literal(&self) -> Option<Literal> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableItem {
    pub(crate) syntax: SyntaxNode,
}
impl TableItem {
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
    #[inline]
    pub fn member_item_property(&self) -> Option<MemberItemProperty> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ListItem {
    pub(crate) syntax: SyntaxNode,
}
impl ListItem {
    #[inline]
    pub fn expr(&self) -> Option<Expr> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableType {
    pub(crate) syntax: SyntaxNode,
}
impl TableType {
    #[inline]
    pub fn l_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["{"])
    }
    #[inline]
    pub fn table_type_items(&self) -> AstChildren<TableTypeItem> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn table_other_type_item(&self) -> Option<TableOtherTypeItem> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn r_curly_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["}"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnType {
    pub(crate) syntax: SyntaxNode,
}
impl FnType {
    #[inline]
    pub fn fn_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![fn])
    }
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn params(&self) -> AstChildren<FnTypeParam> {
        support::children(&self.syntax)
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
    #[inline]
    pub fn ret_type(&self) -> Option<RetType> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenType {
    pub(crate) syntax: SyntaxNode,
}
impl ParenType {
    #[inline]
    pub fn l_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["("])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn r_paren_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![")"])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableTypeItem {
    pub(crate) syntax: SyntaxNode,
}
impl TableTypeItem {
    #[inline]
    pub fn key(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn value(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TableOtherTypeItem {
    pub(crate) syntax: SyntaxNode,
}
impl TableOtherTypeItem {
    #[inline]
    pub fn l_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["["])
    }
    #[inline]
    pub fn key(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn r_brack_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T!["]"])
    }
    #[inline]
    pub fn colon_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![:])
    }
    #[inline]
    pub fn value(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FnTypeParam {
    pub(crate) syntax: SyntaxNode,
}
impl FnTypeParam {
    #[inline]
    pub fn star_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![*])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
    #[inline]
    pub fn comma_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![,])
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnType {
    pub(crate) syntax: SyntaxNode,
}
impl ReturnType {
    #[inline]
    pub fn thin_arrow_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![->])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ThrowType {
    pub(crate) syntax: SyntaxNode,
}
impl ThrowType {
    #[inline]
    pub fn throw_token(&self) -> Option<SyntaxToken> {
        support::token(&self.syntax, T![throw])
    }
    #[inline]
    pub fn ty(&self) -> Option<Type> {
        support::child(&self.syntax)
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Stmt {
    Block(Block),
    IfStmt(IfStmt),
    LoopStmt(LoopStmt),
    WhileStmt(WhileStmt),
    ForStmt(ForStmt),
    BreakStmt(BreakStmt),
    ContinueStmt(ContinueStmt),
    ReturnStmt(ReturnStmt),
    ThrowStmt(ThrowStmt),
    GlobalStmt(GlobalStmt),
    ImportStmt(ImportStmt),
    FnStmt(FnStmt),
    AssignStmt(AssignStmt),
    AssignOpStmt(AssignOpStmt),
    AssignUnpackStmt(AssignUnpackStmt),
    AssignMultiStmt(AssignMultiStmt),
    Expr(Expr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expr {
    BinaryExpr(BinaryExpr),
    UnaryExpr(UnaryExpr),
    CallExpr(CallExpr),
    MemberItemExpr(MemberItemExpr),
    MemberAttrExpr(MemberAttrExpr),
    ParenExpr(ParenExpr),
    TableExpr(TableExpr),
    ListExpr(ListExpr),
    FnExpr(FnExpr),
    ClosureExpr(ClosureExpr),
    DoExpr(DoExpr),
    TryExpr(TryExpr),
    LiteralExpr(LiteralExpr),
    Name(Name),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ElseBranch {
    IfStmt(IfStmt),
    Block(Block),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportKind {
    GlobImport(GlobImport),
    AliasImport(AliasImport),
    NestedImport(NestedImport),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssignLeft {
    Name(Name),
    MemberItemExpr(MemberItemExpr),
    MemberAttrExpr(MemberAttrExpr),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssignOp {
    Assign(SyntaxNode),
    Addassign(SyntaxNode),
    Subassign(SyntaxNode),
    Mulassign(SyntaxNode),
    Divassign(SyntaxNode),
    Remassign(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BinaryOp {
    Is(SyntaxNode),
    And(SyntaxNode),
    Or(SyntaxNode),
    Eq(SyntaxNode),
    Noteq(SyntaxNode),
    Lteq(SyntaxNode),
    Gteq(SyntaxNode),
    Lt(SyntaxNode),
    Gt(SyntaxNode),
    Add(SyntaxNode),
    Sub(SyntaxNode),
    Mul(SyntaxNode),
    Div(SyntaxNode),
    Rem(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UnaryOp {
    Sub(SyntaxNode),
    Not(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MemberItem {
    Openbracket(SyntaxNode),
    Safeopenbracket(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MemberItemProperty {
    Expr(Expr),
    Pound(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MemberAttrKind {
    Dot(SyntaxNode),
    Safedot(SyntaxNode),
    Doublecolon(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MemberAttrProperty {
    Name(Name),
    Pound(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TryKind {
    Question(SyntaxNode),
    Exclamation(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Literal {
    Null(SyntaxNode),
    True(SyntaxNode),
    False(SyntaxNode),
    Int(SyntaxNode),
    Float(SyntaxNode),
    Str(SyntaxNode),
    RawStr(SyntaxNode),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AtomType {
    Name(Name),
    Literal(Literal),
    TableType(TableType),
    FnType(FnType),
    ParenType(ParenType),
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasLoopBody {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasLoopBody for AnyHasLoopBody {}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyHasName {
    pub(crate) syntax: SyntaxNode,
}
impl ast::HasName for AnyHasName {}
impl AstNode for Root {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == Root
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Block {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == Block
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for IfStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == IfStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LoopStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LoopStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for WhileStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == WhileStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ForStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ForStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BreakStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BreakStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ContinueStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ContinueStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ReturnStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ThrowStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ThrowStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GlobalStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GlobalStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ImportStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ImportStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FnStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AssignStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignOpStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AssignOpStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignUnpackStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AssignUnpackStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AssignMultiStmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AssignMultiStmt
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Name {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == Name
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TypedName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TypedName
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for PackagePath {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == PackagePath
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for GlobImport {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == GlobImport
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for AliasImport {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == AliasImport
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for NestedImport {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == NestedImport
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ImportItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ImportItem
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Param {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == Param
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for RetType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == RetType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Type {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == Type
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MemberItemExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MemberItemExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for MemberAttrExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == MemberAttrExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for BinaryExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == BinaryExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for UnaryExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == UnaryExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for CallExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == CallExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParenExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ParenExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TableExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TableExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ListExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FnExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ClosureExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ClosureExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for DoExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == DoExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TryExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TryExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for LiteralExpr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == LiteralExpr
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TableItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TableItem
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ListItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ListItem
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TableType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TableType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FnType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ParenType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ParenType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TableTypeItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TableTypeItem
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for TableOtherTypeItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == TableOtherTypeItem
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for FnTypeParam {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == FnTypeParam
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ReturnType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ReturnType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for ThrowType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        kind == ThrowType
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        if Self::can_cast(syntax.kind()) {
            Some(Self { syntax })
        } else {
            None
        }
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl AstNode for Stmt {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            Block
                | IfStmt
                | LoopStmt
                | WhileStmt
                | ForStmt
                | BreakStmt
                | ContinueStmt
                | ReturnStmt
                | ThrowStmt
                | GlobalStmt
                | ImportStmt
                | FnStmt
                | AssignStmt
                | AssignOpStmt
                | AssignUnpackStmt
                | AssignMultiStmt
        ) || Expr::can_cast(kind)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            Block => Stmt::Block(Block { syntax }),
            IfStmt => Stmt::IfStmt(IfStmt { syntax }),
            LoopStmt => Stmt::LoopStmt(LoopStmt { syntax }),
            WhileStmt => Stmt::WhileStmt(WhileStmt { syntax }),
            ForStmt => Stmt::ForStmt(ForStmt { syntax }),
            BreakStmt => Stmt::BreakStmt(BreakStmt { syntax }),
            ContinueStmt => Stmt::ContinueStmt(ContinueStmt { syntax }),
            ReturnStmt => Stmt::ReturnStmt(ReturnStmt { syntax }),
            ThrowStmt => Stmt::ThrowStmt(ThrowStmt { syntax }),
            GlobalStmt => Stmt::GlobalStmt(GlobalStmt { syntax }),
            ImportStmt => Stmt::ImportStmt(ImportStmt { syntax }),
            FnStmt => Stmt::FnStmt(FnStmt { syntax }),
            AssignStmt => Stmt::AssignStmt(AssignStmt { syntax }),
            AssignOpStmt => Stmt::AssignOpStmt(AssignOpStmt { syntax }),
            AssignUnpackStmt => Stmt::AssignUnpackStmt(AssignUnpackStmt { syntax }),
            AssignMultiStmt => Stmt::AssignMultiStmt(AssignMultiStmt { syntax }),
            _ if Expr::can_cast(syntax.kind()) => Stmt::Expr(Expr::cast(syntax).unwrap()),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Stmt::Block(it) => it.syntax(),
            Stmt::IfStmt(it) => it.syntax(),
            Stmt::LoopStmt(it) => it.syntax(),
            Stmt::WhileStmt(it) => it.syntax(),
            Stmt::ForStmt(it) => it.syntax(),
            Stmt::BreakStmt(it) => it.syntax(),
            Stmt::ContinueStmt(it) => it.syntax(),
            Stmt::ReturnStmt(it) => it.syntax(),
            Stmt::ThrowStmt(it) => it.syntax(),
            Stmt::GlobalStmt(it) => it.syntax(),
            Stmt::ImportStmt(it) => it.syntax(),
            Stmt::FnStmt(it) => it.syntax(),
            Stmt::AssignStmt(it) => it.syntax(),
            Stmt::AssignOpStmt(it) => it.syntax(),
            Stmt::AssignUnpackStmt(it) => it.syntax(),
            Stmt::AssignMultiStmt(it) => it.syntax(),
            Stmt::Expr(it) => it.syntax(),
        }
    }
}
impl From<Block> for Stmt {
    #[inline]
    fn from(node: Block) -> Stmt {
        Stmt::Block(node)
    }
}
impl From<IfStmt> for Stmt {
    #[inline]
    fn from(node: IfStmt) -> Stmt {
        Stmt::IfStmt(node)
    }
}
impl From<LoopStmt> for Stmt {
    #[inline]
    fn from(node: LoopStmt) -> Stmt {
        Stmt::LoopStmt(node)
    }
}
impl From<WhileStmt> for Stmt {
    #[inline]
    fn from(node: WhileStmt) -> Stmt {
        Stmt::WhileStmt(node)
    }
}
impl From<ForStmt> for Stmt {
    #[inline]
    fn from(node: ForStmt) -> Stmt {
        Stmt::ForStmt(node)
    }
}
impl From<BreakStmt> for Stmt {
    #[inline]
    fn from(node: BreakStmt) -> Stmt {
        Stmt::BreakStmt(node)
    }
}
impl From<ContinueStmt> for Stmt {
    #[inline]
    fn from(node: ContinueStmt) -> Stmt {
        Stmt::ContinueStmt(node)
    }
}
impl From<ReturnStmt> for Stmt {
    #[inline]
    fn from(node: ReturnStmt) -> Stmt {
        Stmt::ReturnStmt(node)
    }
}
impl From<ThrowStmt> for Stmt {
    #[inline]
    fn from(node: ThrowStmt) -> Stmt {
        Stmt::ThrowStmt(node)
    }
}
impl From<GlobalStmt> for Stmt {
    #[inline]
    fn from(node: GlobalStmt) -> Stmt {
        Stmt::GlobalStmt(node)
    }
}
impl From<ImportStmt> for Stmt {
    #[inline]
    fn from(node: ImportStmt) -> Stmt {
        Stmt::ImportStmt(node)
    }
}
impl From<FnStmt> for Stmt {
    #[inline]
    fn from(node: FnStmt) -> Stmt {
        Stmt::FnStmt(node)
    }
}
impl From<AssignStmt> for Stmt {
    #[inline]
    fn from(node: AssignStmt) -> Stmt {
        Stmt::AssignStmt(node)
    }
}
impl From<AssignOpStmt> for Stmt {
    #[inline]
    fn from(node: AssignOpStmt) -> Stmt {
        Stmt::AssignOpStmt(node)
    }
}
impl From<AssignUnpackStmt> for Stmt {
    #[inline]
    fn from(node: AssignUnpackStmt) -> Stmt {
        Stmt::AssignUnpackStmt(node)
    }
}
impl From<AssignMultiStmt> for Stmt {
    #[inline]
    fn from(node: AssignMultiStmt) -> Stmt {
        Stmt::AssignMultiStmt(node)
    }
}
impl From<Expr> for Stmt {
    #[inline]
    fn from(node: Expr) -> Stmt {
        Stmt::Expr(node)
    }
}
impl AstNode for Expr {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            BinaryExpr
                | UnaryExpr
                | CallExpr
                | MemberItemExpr
                | MemberAttrExpr
                | ParenExpr
                | TableExpr
                | ListExpr
                | FnExpr
                | ClosureExpr
                | DoExpr
                | TryExpr
                | LiteralExpr
                | Name
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            BinaryExpr => Expr::BinaryExpr(BinaryExpr { syntax }),
            UnaryExpr => Expr::UnaryExpr(UnaryExpr { syntax }),
            CallExpr => Expr::CallExpr(CallExpr { syntax }),
            MemberItemExpr => Expr::MemberItemExpr(MemberItemExpr { syntax }),
            MemberAttrExpr => Expr::MemberAttrExpr(MemberAttrExpr { syntax }),
            ParenExpr => Expr::ParenExpr(ParenExpr { syntax }),
            TableExpr => Expr::TableExpr(TableExpr { syntax }),
            ListExpr => Expr::ListExpr(ListExpr { syntax }),
            FnExpr => Expr::FnExpr(FnExpr { syntax }),
            ClosureExpr => Expr::ClosureExpr(ClosureExpr { syntax }),
            DoExpr => Expr::DoExpr(DoExpr { syntax }),
            TryExpr => Expr::TryExpr(TryExpr { syntax }),
            LiteralExpr => Expr::LiteralExpr(LiteralExpr { syntax }),
            Name => Expr::Name(Name { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Expr::BinaryExpr(it) => it.syntax(),
            Expr::UnaryExpr(it) => it.syntax(),
            Expr::CallExpr(it) => it.syntax(),
            Expr::MemberItemExpr(it) => it.syntax(),
            Expr::MemberAttrExpr(it) => it.syntax(),
            Expr::ParenExpr(it) => it.syntax(),
            Expr::TableExpr(it) => it.syntax(),
            Expr::ListExpr(it) => it.syntax(),
            Expr::FnExpr(it) => it.syntax(),
            Expr::ClosureExpr(it) => it.syntax(),
            Expr::DoExpr(it) => it.syntax(),
            Expr::TryExpr(it) => it.syntax(),
            Expr::LiteralExpr(it) => it.syntax(),
            Expr::Name(it) => it.syntax(),
        }
    }
}
impl From<BinaryExpr> for Expr {
    #[inline]
    fn from(node: BinaryExpr) -> Expr {
        Expr::BinaryExpr(node)
    }
}
impl From<UnaryExpr> for Expr {
    #[inline]
    fn from(node: UnaryExpr) -> Expr {
        Expr::UnaryExpr(node)
    }
}
impl From<CallExpr> for Expr {
    #[inline]
    fn from(node: CallExpr) -> Expr {
        Expr::CallExpr(node)
    }
}
impl From<MemberItemExpr> for Expr {
    #[inline]
    fn from(node: MemberItemExpr) -> Expr {
        Expr::MemberItemExpr(node)
    }
}
impl From<MemberAttrExpr> for Expr {
    #[inline]
    fn from(node: MemberAttrExpr) -> Expr {
        Expr::MemberAttrExpr(node)
    }
}
impl From<ParenExpr> for Expr {
    #[inline]
    fn from(node: ParenExpr) -> Expr {
        Expr::ParenExpr(node)
    }
}
impl From<TableExpr> for Expr {
    #[inline]
    fn from(node: TableExpr) -> Expr {
        Expr::TableExpr(node)
    }
}
impl From<ListExpr> for Expr {
    #[inline]
    fn from(node: ListExpr) -> Expr {
        Expr::ListExpr(node)
    }
}
impl From<FnExpr> for Expr {
    #[inline]
    fn from(node: FnExpr) -> Expr {
        Expr::FnExpr(node)
    }
}
impl From<ClosureExpr> for Expr {
    #[inline]
    fn from(node: ClosureExpr) -> Expr {
        Expr::ClosureExpr(node)
    }
}
impl From<DoExpr> for Expr {
    #[inline]
    fn from(node: DoExpr) -> Expr {
        Expr::DoExpr(node)
    }
}
impl From<TryExpr> for Expr {
    #[inline]
    fn from(node: TryExpr) -> Expr {
        Expr::TryExpr(node)
    }
}
impl From<LiteralExpr> for Expr {
    #[inline]
    fn from(node: LiteralExpr) -> Expr {
        Expr::LiteralExpr(node)
    }
}
impl From<Name> for Expr {
    #[inline]
    fn from(node: Name) -> Expr {
        Expr::Name(node)
    }
}
impl AstNode for ElseBranch {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, IfStmt | Block)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            IfStmt => ElseBranch::IfStmt(IfStmt { syntax }),
            Block => ElseBranch::Block(Block { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ElseBranch::IfStmt(it) => it.syntax(),
            ElseBranch::Block(it) => it.syntax(),
        }
    }
}
impl From<IfStmt> for ElseBranch {
    #[inline]
    fn from(node: IfStmt) -> ElseBranch {
        ElseBranch::IfStmt(node)
    }
}
impl From<Block> for ElseBranch {
    #[inline]
    fn from(node: Block) -> ElseBranch {
        ElseBranch::Block(node)
    }
}
impl AstNode for ImportKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, GlobImport | AliasImport | NestedImport)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            GlobImport => ImportKind::GlobImport(GlobImport { syntax }),
            AliasImport => ImportKind::AliasImport(AliasImport { syntax }),
            NestedImport => ImportKind::NestedImport(NestedImport { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            ImportKind::GlobImport(it) => it.syntax(),
            ImportKind::AliasImport(it) => it.syntax(),
            ImportKind::NestedImport(it) => it.syntax(),
        }
    }
}
impl From<GlobImport> for ImportKind {
    #[inline]
    fn from(node: GlobImport) -> ImportKind {
        ImportKind::GlobImport(node)
    }
}
impl From<AliasImport> for ImportKind {
    #[inline]
    fn from(node: AliasImport) -> ImportKind {
        ImportKind::AliasImport(node)
    }
}
impl From<NestedImport> for ImportKind {
    #[inline]
    fn from(node: NestedImport) -> ImportKind {
        ImportKind::NestedImport(node)
    }
}
impl AstNode for AssignLeft {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, Name | MemberItemExpr | MemberAttrExpr)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            Name => AssignLeft::Name(Name { syntax }),
            MemberItemExpr => AssignLeft::MemberItemExpr(MemberItemExpr { syntax }),
            MemberAttrExpr => AssignLeft::MemberAttrExpr(MemberAttrExpr { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AssignLeft::Name(it) => it.syntax(),
            AssignLeft::MemberItemExpr(it) => it.syntax(),
            AssignLeft::MemberAttrExpr(it) => it.syntax(),
        }
    }
}
impl From<Name> for AssignLeft {
    #[inline]
    fn from(node: Name) -> AssignLeft {
        AssignLeft::Name(node)
    }
}
impl From<MemberItemExpr> for AssignLeft {
    #[inline]
    fn from(node: MemberItemExpr) -> AssignLeft {
        AssignLeft::MemberItemExpr(node)
    }
}
impl From<MemberAttrExpr> for AssignLeft {
    #[inline]
    fn from(node: MemberAttrExpr) -> AssignLeft {
        AssignLeft::MemberAttrExpr(node)
    }
}
impl AstNode for AssignOp {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T![=] | T![+=] | T![-=] | T![*=] | T![/=] | T![%=])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T![=] => AssignOp::Assign(syntax),
            T![+=] => AssignOp::Addassign(syntax),
            T![-=] => AssignOp::Subassign(syntax),
            T![*=] => AssignOp::Mulassign(syntax),
            T![/=] => AssignOp::Divassign(syntax),
            T![%=] => AssignOp::Remassign(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AssignOp::Assign(it) => it,
            AssignOp::Addassign(it) => it,
            AssignOp::Subassign(it) => it,
            AssignOp::Mulassign(it) => it,
            AssignOp::Divassign(it) => it,
            AssignOp::Remassign(it) => it,
        }
    }
}
impl AstNode for BinaryOp {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            T![is]
                | T![and]
                | T![or]
                | T![==]
                | T![!=]
                | T![<=]
                | T![>=]
                | T![<]
                | T![>]
                | T![+]
                | T![-]
                | T![*]
                | T![/]
                | T![%]
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T![is] => BinaryOp::Is(syntax),
            T![and] => BinaryOp::And(syntax),
            T![or] => BinaryOp::Or(syntax),
            T![==] => BinaryOp::Eq(syntax),
            T![!=] => BinaryOp::Noteq(syntax),
            T![<=] => BinaryOp::Lteq(syntax),
            T![>=] => BinaryOp::Gteq(syntax),
            T![<] => BinaryOp::Lt(syntax),
            T![>] => BinaryOp::Gt(syntax),
            T![+] => BinaryOp::Add(syntax),
            T![-] => BinaryOp::Sub(syntax),
            T![*] => BinaryOp::Mul(syntax),
            T![/] => BinaryOp::Div(syntax),
            T![%] => BinaryOp::Rem(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            BinaryOp::Is(it) => it,
            BinaryOp::And(it) => it,
            BinaryOp::Or(it) => it,
            BinaryOp::Eq(it) => it,
            BinaryOp::Noteq(it) => it,
            BinaryOp::Lteq(it) => it,
            BinaryOp::Gteq(it) => it,
            BinaryOp::Lt(it) => it,
            BinaryOp::Gt(it) => it,
            BinaryOp::Add(it) => it,
            BinaryOp::Sub(it) => it,
            BinaryOp::Mul(it) => it,
            BinaryOp::Div(it) => it,
            BinaryOp::Rem(it) => it,
        }
    }
}
impl AstNode for UnaryOp {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T![-] | T![not])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T![-] => UnaryOp::Sub(syntax),
            T![not] => UnaryOp::Not(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            UnaryOp::Sub(it) => it,
            UnaryOp::Not(it) => it,
        }
    }
}
impl AstNode for MemberItem {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T!["["] | T!["?["])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T!["["] => MemberItem::Openbracket(syntax),
            T!["?["] => MemberItem::Safeopenbracket(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MemberItem::Openbracket(it) => it,
            MemberItem::Safeopenbracket(it) => it,
        }
    }
}
impl AstNode for MemberItemProperty {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T![#]) || Expr::can_cast(kind)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            _ if Expr::can_cast(syntax.kind()) => {
                MemberItemProperty::Expr(Expr::cast(syntax).unwrap())
            }
            T![#] => MemberItemProperty::Pound(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MemberItemProperty::Expr(it) => it.syntax(),
            MemberItemProperty::Pound(it) => it,
        }
    }
}
impl From<Expr> for MemberItemProperty {
    #[inline]
    fn from(node: Expr) -> MemberItemProperty {
        MemberItemProperty::Expr(node)
    }
}
impl AstNode for MemberAttrKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T![.] | T![?.] | T![::])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T![.] => MemberAttrKind::Dot(syntax),
            T![?.] => MemberAttrKind::Safedot(syntax),
            T![::] => MemberAttrKind::Doublecolon(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MemberAttrKind::Dot(it) => it,
            MemberAttrKind::Safedot(it) => it,
            MemberAttrKind::Doublecolon(it) => it,
        }
    }
}
impl AstNode for MemberAttrProperty {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, Name | T![#])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            Name => MemberAttrProperty::Name(Name { syntax }),
            T![#] => MemberAttrProperty::Pound(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            MemberAttrProperty::Name(it) => it.syntax(),
            MemberAttrProperty::Pound(it) => it,
        }
    }
}
impl From<Name> for MemberAttrProperty {
    #[inline]
    fn from(node: Name) -> MemberAttrProperty {
        MemberAttrProperty::Name(node)
    }
}
impl AstNode for TryKind {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, T!["?"] | T![!])
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T!["?"] => TryKind::Question(syntax),
            T![!] => TryKind::Exclamation(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            TryKind::Question(it) => it,
            TryKind::Exclamation(it) => it,
        }
    }
}
impl AstNode for Literal {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(
            kind,
            T![null] | T![true] | T![false] | T![int] | T![float] | T![str] | T![raw_str]
        )
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            T![null] => Literal::Null(syntax),
            T![true] => Literal::True(syntax),
            T![false] => Literal::False(syntax),
            T![int] => Literal::Int(syntax),
            T![float] => Literal::Float(syntax),
            T![str] => Literal::Str(syntax),
            T![raw_str] => Literal::RawStr(syntax),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            Literal::Null(it) => it,
            Literal::True(it) => it,
            Literal::False(it) => it,
            Literal::Int(it) => it,
            Literal::Float(it) => it,
            Literal::Str(it) => it,
            Literal::RawStr(it) => it,
        }
    }
}
impl AstNode for AtomType {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, Name | TableType | FnType | ParenType) || Literal::can_cast(kind)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        let res = match syntax.kind() {
            Name => AtomType::Name(Name { syntax }),
            _ if Literal::can_cast(syntax.kind()) => {
                AtomType::Literal(Literal::cast(syntax).unwrap())
            }
            TableType => AtomType::TableType(TableType { syntax }),
            FnType => AtomType::FnType(FnType { syntax }),
            ParenType => AtomType::ParenType(ParenType { syntax }),
            _ => return None,
        };
        Some(res)
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        match self {
            AtomType::Name(it) => it.syntax(),
            AtomType::Literal(it) => it.syntax(),
            AtomType::TableType(it) => it.syntax(),
            AtomType::FnType(it) => it.syntax(),
            AtomType::ParenType(it) => it.syntax(),
        }
    }
}
impl From<Name> for AtomType {
    #[inline]
    fn from(node: Name) -> AtomType {
        AtomType::Name(node)
    }
}
impl From<Literal> for AtomType {
    #[inline]
    fn from(node: Literal) -> AtomType {
        AtomType::Literal(node)
    }
}
impl From<TableType> for AtomType {
    #[inline]
    fn from(node: TableType) -> AtomType {
        AtomType::TableType(node)
    }
}
impl From<FnType> for AtomType {
    #[inline]
    fn from(node: FnType) -> AtomType {
        AtomType::FnType(node)
    }
}
impl From<ParenType> for AtomType {
    #[inline]
    fn from(node: ParenType) -> AtomType {
        AtomType::ParenType(node)
    }
}
impl AnyHasLoopBody {
    #[inline]
    pub fn new<T: ast::HasLoopBody>(node: T) -> AnyHasLoopBody {
        AnyHasLoopBody {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasLoopBody {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, LoopStmt | WhileStmt | ForStmt)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasLoopBody { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<LoopStmt> for AnyHasLoopBody {
    #[inline]
    fn from(node: LoopStmt) -> AnyHasLoopBody {
        AnyHasLoopBody {
            syntax: node.syntax,
        }
    }
}
impl From<WhileStmt> for AnyHasLoopBody {
    #[inline]
    fn from(node: WhileStmt) -> AnyHasLoopBody {
        AnyHasLoopBody {
            syntax: node.syntax,
        }
    }
}
impl From<ForStmt> for AnyHasLoopBody {
    #[inline]
    fn from(node: ForStmt) -> AnyHasLoopBody {
        AnyHasLoopBody {
            syntax: node.syntax,
        }
    }
}
impl AnyHasName {
    #[inline]
    pub fn new<T: ast::HasName>(node: T) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax().clone(),
        }
    }
}
impl AstNode for AnyHasName {
    #[inline]
    fn can_cast(kind: SyntaxKind) -> bool {
        matches!(kind, FnStmt | TypedName)
    }
    #[inline]
    fn cast(syntax: SyntaxNode) -> Option<Self> {
        Self::can_cast(syntax.kind()).then_some(AnyHasName { syntax })
    }
    #[inline]
    fn syntax(&self) -> &SyntaxNode {
        &self.syntax
    }
}
impl From<FnStmt> for AnyHasName {
    #[inline]
    fn from(node: FnStmt) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl From<TypedName> for AnyHasName {
    #[inline]
    fn from(node: TypedName) -> AnyHasName {
        AnyHasName {
            syntax: node.syntax,
        }
    }
}
impl std::fmt::Display for Stmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Expr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ElseBranch {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignLeft {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinaryOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnaryOp {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberItemProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberAttrKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberAttrProperty {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryKind {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Literal {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AtomType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Root {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Block {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for IfStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LoopStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for WhileStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ForStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BreakStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ContinueStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ThrowStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GlobalStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignOpStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignUnpackStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AssignMultiStmt {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Name {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TypedName {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for PackagePath {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for GlobImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for AliasImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for NestedImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ImportItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Param {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for RetType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for Type {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberItemExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for MemberAttrExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for BinaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for UnaryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for CallExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TableExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ClosureExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for DoExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TryExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for LiteralExpr {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TableItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ListItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TableType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ParenType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TableTypeItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for TableOtherTypeItem {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for FnTypeParam {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ReturnType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
impl std::fmt::Display for ThrowType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        std::fmt::Display::fmt(self.syntax(), f)
    }
}
