//! The parsed token generated by the lexer.

use std::fmt;

use rowan::TextRange;

/// Parsed token.
#[derive(Debug, Clone)]
pub struct Token<'a> {
    /// The kind of the token.
    pub kind: TokenKind,
    /// The text of the token.
    pub text: &'a str,
    /// The range in source text of the token.
    pub range: TextRange,
}

impl<'a> Token<'a> {
    pub fn new(kind: TokenKind, text: &'a str, range: TextRange) -> Token<'a> {
        Token { kind, text, range }
    }
}

impl fmt::Display for Token<'_> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{}@{:?} {:?}", self.kind, self.range, self.text)
    }
}

/// Enum representing common lexeme types.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum TokenKind {
    // Multi-char tokens:
    /// "// comment"
    LineComment,

    /// `/* block comment */`
    ///
    /// Block comments can be recursive, so a sequence like `/* /* */`
    BlockComment,

    /// Any whitespace character sequence.
    Whitespace,

    /// "ident"
    Ident,

    // Literals:
    /// "12_u8", "0o100", "0b120", "1".
    Int,
    /// "12.34", "1e3".
    Float,
    /// ""abc""
    Str,
    /// "r"abc"", "r#"abc"#", "r####"ab"###"c"####", "r#"a".
    RawStr,

    // Keywords:
    /// "if"
    If,
    /// "else"
    Else,
    /// "loop"
    Loop,
    /// "while"
    While,
    /// "for"
    For,
    /// "in"
    In,
    /// "break"
    Break,
    /// "continue"
    Continue,
    /// "return"
    Return,
    /// "throw"
    Throw,
    /// "global"
    Global,
    /// "import"
    Import,
    /// "as"
    As,
    /// "is"
    Is,
    /// "not"
    Not,
    /// "and"
    And,
    /// "or"
    Or,
    /// "try"
    Try,
    /// "fn"
    Fn,
    /// "do"
    Do,
    /// "null"
    Null,
    /// "true"
    True,
    /// "false"
    False,

    // Two-char tokens:
    /// "::"
    DoubleColon,
    /// "?."
    SafeDot,
    /// "?["
    SafeOpenBracket,
    /// "->"
    Arrow,
    /// "=="
    Eq,
    /// "!="
    NotEq,
    /// "<="
    LtEq,
    /// ">="
    GtEq,
    /// "+="
    AddAssign,
    /// "-="
    SubAssign,
    /// "*="
    MulAssign,
    /// "/="
    DivAssign,
    /// "%="
    RemAssign,

    // One-char tokens:
    /// ","
    Comma,
    /// "."
    Dot,
    /// "("
    OpenParen,
    /// ")"
    CloseParen,
    /// "{"
    OpenBrace,
    /// "}"
    CloseBrace,
    /// "["
    OpenBracket,
    /// "]"
    CloseBracket,
    /// "#"
    Pound,
    /// "?"
    Question,
    /// "!"
    Exclamation,
    /// ":"
    Colon,
    /// "="
    Assign,
    /// "<"
    Lt,
    /// ">"
    Gt,
    /// "|"
    VBar,
    /// "+"
    Add,
    /// "-"
    Sub,
    /// "*"
    Mul,
    /// "/"
    Div,
    /// "%"
    Rem,
    /// End of line (`\n`)
    Eol,

    /// End of input.
    Eof,

    // Errors:
    /// Unknown token, not expected by the lexer, e.g. "â„–"
    Unknown,
    /// Unterminated block comment, e.g. `/*`.
    UnterminatedBlockComment,
    /// An integer literal with only base prefix, e.g. `0x`.
    EmptyInt,
    /// An empty exponent in a float literal, e.g. `1.0e`.
    EmptyExponentFloat,
    /// Unterminated string literal, e.g. `"abc`.
    UnterminatedStr,
}

impl TokenKind {
    pub fn is_trivia(self) -> bool {
        matches!(
            self,
            Self::LineComment | Self::BlockComment | Self::Whitespace
        )
    }
}

impl fmt::Display for TokenKind {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Debug::fmt(&self, f)
    }
}
