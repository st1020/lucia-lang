//! Generated by `cargo codegen`, do not edit by hand.

#![allow(bad_style, missing_docs, unreachable_pub)]
use crate::compiler_new::token::TokenKind;
#[doc = r" The kind of syntax node, e.g. `IDENT`, `USE_KW`, or `STRUCT`."]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
#[repr(u16)]
pub enum SyntaxKind {
    Error,
    Comma,
    Dot,
    OpenParen,
    CloseParen,
    OpenBrace,
    CloseBrace,
    OpenBracket,
    CloseBracket,
    Pound,
    Question,
    Exclamation,
    Colon,
    Assign,
    Lt,
    Gt,
    VBar,
    Add,
    Sub,
    Mul,
    Div,
    Rem,
    DoubleColon,
    SafeDot,
    SafeOpenBracket,
    Arrow,
    Eq,
    NotEq,
    LtEq,
    GtEq,
    AddAssign,
    SubAssign,
    MulAssign,
    DivAssign,
    RemAssign,
    AndKw,
    AsKw,
    BreakKw,
    ContinueKw,
    DoKw,
    ElseKw,
    FalseKw,
    FnKw,
    ForKw,
    GlobalKw,
    IfKw,
    ImportKw,
    InKw,
    IsKw,
    LoopKw,
    NotKw,
    NullKw,
    OrKw,
    ReturnKw,
    ThrowKw,
    TrueKw,
    TryKw,
    WhileKw,
    Float,
    Int,
    RawStr,
    Str,
    BlockComment,
    Eof,
    Eol,
    Ident,
    LineComment,
    Whitespace,
    AliasImport,
    AssignMultiStmt,
    AssignOpStmt,
    AssignStmt,
    AssignUnpackStmt,
    BinaryExpr,
    Block,
    BreakStmt,
    CallExpr,
    ClosureExpr,
    ContinueStmt,
    DoExpr,
    FnExpr,
    FnStmt,
    FnType,
    FnTypeParam,
    ForStmt,
    GlobImport,
    GlobalStmt,
    IfStmt,
    ImportItem,
    ImportStmt,
    ListExpr,
    ListItem,
    LiteralExpr,
    LoopStmt,
    MemberAttrExpr,
    MemberItemExpr,
    Name,
    NestedImport,
    PackagePath,
    Param,
    ParenExpr,
    ParenType,
    RetType,
    ReturnStmt,
    ReturnType,
    Root,
    TableExpr,
    TableItem,
    TableOtherTypeItem,
    TableType,
    TableTypeItem,
    ThrowStmt,
    ThrowType,
    TryExpr,
    Type,
    TypedName,
    UnaryExpr,
    WhileStmt,
    #[doc(hidden)]
    __LAST,
}
use self::SyntaxKind::*;
impl SyntaxKind {
    pub fn is_keyword(self) -> bool {
        matches!(
            self,
            AndKw
                | AsKw
                | BreakKw
                | ContinueKw
                | DoKw
                | ElseKw
                | FalseKw
                | FnKw
                | ForKw
                | GlobalKw
                | IfKw
                | ImportKw
                | InKw
                | IsKw
                | LoopKw
                | NotKw
                | NullKw
                | OrKw
                | ReturnKw
                | ThrowKw
                | TrueKw
                | TryKw
                | WhileKw
        )
    }
    pub fn is_punct(self) -> bool {
        matches!(
            self,
            Comma
                | Dot
                | OpenParen
                | CloseParen
                | OpenBrace
                | CloseBrace
                | OpenBracket
                | CloseBracket
                | Pound
                | Question
                | Exclamation
                | Colon
                | Assign
                | Lt
                | Gt
                | VBar
                | Add
                | Sub
                | Mul
                | Div
                | Rem
                | DoubleColon
                | SafeDot
                | SafeOpenBracket
                | Arrow
                | Eq
                | NotEq
                | LtEq
                | GtEq
                | AddAssign
                | SubAssign
                | MulAssign
                | DivAssign
                | RemAssign
        )
    }
    pub fn is_literal(self) -> bool {
        matches!(self, Float | Int | RawStr | Str)
    }
    pub fn from_keyword(ident: &str) -> Option<SyntaxKind> {
        let kw = match ident {
            "and" => AndKw,
            "as" => AsKw,
            "break" => BreakKw,
            "continue" => ContinueKw,
            "do" => DoKw,
            "else" => ElseKw,
            "false" => FalseKw,
            "fn" => FnKw,
            "for" => ForKw,
            "global" => GlobalKw,
            "if" => IfKw,
            "import" => ImportKw,
            "in" => InKw,
            "is" => IsKw,
            "loop" => LoopKw,
            "not" => NotKw,
            "null" => NullKw,
            "or" => OrKw,
            "return" => ReturnKw,
            "throw" => ThrowKw,
            "true" => TrueKw,
            "try" => TryKw,
            "while" => WhileKw,
            _ => return None,
        };
        Some(kw)
    }
    pub fn from_char(c: char) -> Option<SyntaxKind> {
        let tok = match c {
            ',' => Comma,
            '.' => Dot,
            '(' => OpenParen,
            ')' => CloseParen,
            '{' => OpenBrace,
            '}' => CloseBrace,
            '[' => OpenBracket,
            ']' => CloseBracket,
            '#' => Pound,
            '?' => Question,
            '!' => Exclamation,
            ':' => Colon,
            '=' => Assign,
            '<' => Lt,
            '>' => Gt,
            '|' => VBar,
            '+' => Add,
            '-' => Sub,
            '*' => Mul,
            '/' => Div,
            '%' => Rem,
            _ => return None,
        };
        Some(tok)
    }
}
impl From<TokenKind> for SyntaxKind {
    fn from(value: TokenKind) -> Self {
        match value {
            TokenKind::BlockComment => SyntaxKind::BlockComment,
            TokenKind::Eof => SyntaxKind::Eof,
            TokenKind::Eol => SyntaxKind::Eol,
            TokenKind::Ident => SyntaxKind::Ident,
            TokenKind::LineComment => SyntaxKind::LineComment,
            TokenKind::Whitespace => SyntaxKind::Whitespace,
            TokenKind::And => SyntaxKind::AndKw,
            TokenKind::As => SyntaxKind::AsKw,
            TokenKind::Break => SyntaxKind::BreakKw,
            TokenKind::Continue => SyntaxKind::ContinueKw,
            TokenKind::Do => SyntaxKind::DoKw,
            TokenKind::Else => SyntaxKind::ElseKw,
            TokenKind::False => SyntaxKind::FalseKw,
            TokenKind::Fn => SyntaxKind::FnKw,
            TokenKind::For => SyntaxKind::ForKw,
            TokenKind::Global => SyntaxKind::GlobalKw,
            TokenKind::If => SyntaxKind::IfKw,
            TokenKind::Import => SyntaxKind::ImportKw,
            TokenKind::In => SyntaxKind::InKw,
            TokenKind::Is => SyntaxKind::IsKw,
            TokenKind::Loop => SyntaxKind::LoopKw,
            TokenKind::Not => SyntaxKind::NotKw,
            TokenKind::Null => SyntaxKind::NullKw,
            TokenKind::Or => SyntaxKind::OrKw,
            TokenKind::Return => SyntaxKind::ReturnKw,
            TokenKind::Throw => SyntaxKind::ThrowKw,
            TokenKind::True => SyntaxKind::TrueKw,
            TokenKind::Try => SyntaxKind::TryKw,
            TokenKind::While => SyntaxKind::WhileKw,
            TokenKind::Comma => SyntaxKind::Comma,
            TokenKind::Dot => SyntaxKind::Dot,
            TokenKind::OpenParen => SyntaxKind::OpenParen,
            TokenKind::CloseParen => SyntaxKind::CloseParen,
            TokenKind::OpenBrace => SyntaxKind::OpenBrace,
            TokenKind::CloseBrace => SyntaxKind::CloseBrace,
            TokenKind::OpenBracket => SyntaxKind::OpenBracket,
            TokenKind::CloseBracket => SyntaxKind::CloseBracket,
            TokenKind::Pound => SyntaxKind::Pound,
            TokenKind::Question => SyntaxKind::Question,
            TokenKind::Exclamation => SyntaxKind::Exclamation,
            TokenKind::Colon => SyntaxKind::Colon,
            TokenKind::Assign => SyntaxKind::Assign,
            TokenKind::Lt => SyntaxKind::Lt,
            TokenKind::Gt => SyntaxKind::Gt,
            TokenKind::VBar => SyntaxKind::VBar,
            TokenKind::Add => SyntaxKind::Add,
            TokenKind::Sub => SyntaxKind::Sub,
            TokenKind::Mul => SyntaxKind::Mul,
            TokenKind::Div => SyntaxKind::Div,
            TokenKind::Rem => SyntaxKind::Rem,
            TokenKind::DoubleColon => SyntaxKind::DoubleColon,
            TokenKind::SafeDot => SyntaxKind::SafeDot,
            TokenKind::SafeOpenBracket => SyntaxKind::SafeOpenBracket,
            TokenKind::Arrow => SyntaxKind::Arrow,
            TokenKind::Eq => SyntaxKind::Eq,
            TokenKind::NotEq => SyntaxKind::NotEq,
            TokenKind::LtEq => SyntaxKind::LtEq,
            TokenKind::GtEq => SyntaxKind::GtEq,
            TokenKind::AddAssign => SyntaxKind::AddAssign,
            TokenKind::SubAssign => SyntaxKind::SubAssign,
            TokenKind::MulAssign => SyntaxKind::MulAssign,
            TokenKind::DivAssign => SyntaxKind::DivAssign,
            TokenKind::RemAssign => SyntaxKind::RemAssign,
            TokenKind::Float => SyntaxKind::Float,
            TokenKind::Int => SyntaxKind::Int,
            TokenKind::RawStr => SyntaxKind::RawStr,
            TokenKind::Str => SyntaxKind::Str,
            _ => Error,
        }
    }
}
#[macro_export]
macro_rules ! T { [,] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Comma } ; [.] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Dot } ; ["("] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: OpenParen } ; [")"] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: CloseParen } ; ["{"] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: OpenBrace } ; ["}"] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: CloseBrace } ; ["["] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: OpenBracket } ; ["]"] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: CloseBracket } ; [#] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Pound } ; ["?"] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Question } ; [!] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Exclamation } ; [:] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Colon } ; [=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Assign } ; [<] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Lt } ; [>] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Gt } ; [|] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: VBar } ; [+] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Add } ; [-] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Sub } ; [*] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Mul } ; [/] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Div } ; [%] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Rem } ; [::] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: DoubleColon } ; [?.] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: SafeDot } ; ["?["] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: SafeOpenBracket } ; [->] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Arrow } ; [==] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Eq } ; [!=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: NotEq } ; [<=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: LtEq } ; [>=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: GtEq } ; [+=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: AddAssign } ; [-=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: SubAssign } ; [*=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: MulAssign } ; [/=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: DivAssign } ; [%=] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: RemAssign } ; [and] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: AndKw } ; [as] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: AsKw } ; [break] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: BreakKw } ; [continue] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ContinueKw } ; [do] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: DoKw } ; [else] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ElseKw } ; [false] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: FalseKw } ; [fn] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: FnKw } ; [for] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ForKw } ; [global] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: GlobalKw } ; [if] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: IfKw } ; [import] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ImportKw } ; [in] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: InKw } ; [is] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: IsKw } ; [loop] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: LoopKw } ; [not] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: NotKw } ; [null] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: NullKw } ; [or] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: OrKw } ; [return] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ReturnKw } ; [throw] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: ThrowKw } ; [true] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: TrueKw } ; [try] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: TryKw } ; [while] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: WhileKw } ; [float] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Float } ; [int] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Int } ; [raw_str] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: RawStr } ; [str] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Str } ; [block_comment] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: BlockComment } ; [eof] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Eof } ; [eol] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Eol } ; [ident] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Ident } ; [line_comment] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: LineComment } ; [whitespace] => { $ crate :: compiler_new :: syntax :: SyntaxKind :: Whitespace } ; }
