//! The Code that runs in LVM.

use std::fmt;

use itertools::Itertools;

use crate::utils::Float;

pub use super::ast::FunctionKind;
use super::opcode::OpCode;

// The upvalue may be captured from local variable or upvalue of parent closure.
// For deeper closure which use the upvalue from non-direct parent closure, like:
// ```lucia
// x = 0
// a = || {
//     b = || {
//         return x
//     }
// }
// ```
// In main function, the `x` is declared as a local variable.
// In `a`, it is a upvalue which capture from the parent closure's local variable.
// In `b`, it is a upvalue which capture from the parent closure's upvalue variable.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UpvalueCapture {
    Local(usize),
    Upvalue(usize),
}

/// A Code, generated by codegen and executed in LVM.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Code<S> {
    /// Function name.
    pub name: Option<S>,
    /// Name of parameters.
    pub params: Vec<S>,
    /// Name of variadic parameter.
    pub variadic: Option<S>,
    /// Function kind.
    pub kind: FunctionKind,
    /// Bytecode, a list of OpCodes.
    pub code: Vec<OpCode>,

    /// List of constants used in the bytecode.
    pub consts: Vec<ConstValue<S>>,
    /// List of local names.
    pub local_names: Vec<S>,
    /// List of global names.
    pub global_names: Vec<S>,
    /// List of Upvalue information.
    pub upvalue_names: Vec<(S, UpvalueCapture)>,

    /// The required virtual machine stack space.
    pub stack_size: usize,
}

impl<S: fmt::Display> fmt::Display for Code<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(name) = &self.name {
            writeln!(f, "name: {name}")?;
        }
        if let Some(v) = &self.variadic {
            writeln!(f, "params: ({}, ...{})", self.params.iter().join(", "), v)?;
        } else {
            writeln!(f, "params: ({})", self.params.iter().join(", "))?;
        }
        writeln!(f, "kind: {}", self.kind)?;
        writeln!(f, "stack_size: {}", self.stack_size)?;
        writeln!(f, "consts: {}", self.consts.iter().join(", "))?;
        writeln!(f, "local_names: {}", self.local_names.iter().join(", "))?;
        writeln!(f, "global_names: {}", self.global_names.iter().join(", "))?;
        writeln!(
            f,
            "upvalue_names: {}",
            self.upvalue_names
                .iter()
                .map(|(name, base_closure_upvalue_id)| {
                    format!("({name}, {base_closure_upvalue_id:?})")
                })
                .join(", ")
        )?;
        #[expect(clippy::wildcard_enum_match_arm)]
        let code_str = self
            .code
            .iter()
            .enumerate()
            .map(|(index, code)| {
                format!(
                    "{index:>12} {code}{}",
                    match code {
                        OpCode::LoadLocal(i) | OpCode::StoreLocal(i) =>
                            format!(" ({})", self.local_names[*i]),
                        OpCode::LoadGlobal(i) | OpCode::StoreGlobal(i) =>
                            format!(" ({})", self.global_names[*i]),
                        OpCode::LoadUpvalue(i) => {
                            let (name, base_closure_upvalue_id) = &self.upvalue_names[*i];
                            format!(" ({name}, {base_closure_upvalue_id:?})")
                        }
                        OpCode::LoadConst(i) | OpCode::Import(i) | OpCode::ImportFrom(i) =>
                            format!(" ({})", self.consts[*i]),
                        _ => String::new(),
                    }
                )
            })
            .join("\n");
        write!(f, "code:\n{code_str}")
    }
}

/// The const value.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstValue<S> {
    /// "null"
    Null,
    /// "true", "false"
    Bool(bool),
    /// "12", "0o100", "0b110"
    Int(i64),
    /// "12.34", "0b100.100"
    Float(Float),
    /// ""abc"", ""abc"
    Str(S),
    /// "b"abc""
    Bytes(Vec<u8>),
    /// A function code.
    Code(Box<Code<S>>),
}

impl<S: fmt::Display> fmt::Display for ConstValue<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::Null => write!(f, "null"),
            Self::Bool(v) => write!(f, "{v}"),
            Self::Int(v) => write!(f, "{v}"),
            Self::Float(v) => write!(f, "{v}"),
            Self::Str(v) => write!(f, "{v}"),
            Self::Bytes(v) => write!(f, "b\"{}\"", v.escape_ascii()),
            Self::Code(_) => write!(f, "<code>"),
        }
    }
}
