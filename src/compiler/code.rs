//! The Code that runs in LVM.

use std::{fmt, rc::Rc};

use derive_more::From;
use itertools::Itertools;
use oxc_index::IndexVec;

use crate::utils::Float;

pub use super::ast::FunctionKind;
use super::{
    index::{CodeId, ConstCodeId, ConstId, GlobalNameId, LocalNameId, UpvalueNameId},
    opcode::OpCode,
    value::{BuiltinEffect, ValueType},
};

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CodeParams<S> {
    /// Name of parameters.
    pub params: Vec<S>,
    /// Name of variadic parameter.
    pub variadic: Option<S>,
}

impl<S> CodeParams<S> {
    pub fn info(&self) -> CodeParamsInfo {
        CodeParamsInfo {
            params_count: self.params.len(),
            has_variadic: self.variadic.is_some(),
        }
    }
}

impl<S: fmt::Display> fmt::Display for CodeParams<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "{}",
            self.params
                .iter()
                .map(ToString::to_string)
                .chain(
                    self.variadic
                        .iter()
                        .map(|variadic| format!("...{variadic}")),
                )
                .join(", ")
        )
    }
}

#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CodeParamsInfo {
    /// Number of parameters.
    pub params_count: usize,
    /// Whether has variadic parameter.
    pub has_variadic: bool,
}

// The upvalue may be captured from local variable or upvalue of parent closure.
// For deeper closure which use the upvalue from non-direct parent closure, like:
// ```lucia
// x = 0
// a = || {
//     b = || {
//         return x
//     }
// }
// ```
// In main function, the `x` is declared as a local variable.
// In `a`, it is a upvalue which capture from the parent closure's local variable.
// In `b`, it is a upvalue which capture from the parent closure's upvalue variable.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UpvalueCapture {
    Local(LocalNameId),
    Upvalue(UpvalueNameId),
}

/// A Code, generated by codegen and executed in LVM.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Code<S> {
    /// Function name.
    pub name: Option<S>,
    /// Function parameters.
    pub params: CodeParams<S>,
    /// Function kind.
    pub kind: FunctionKind,
    /// Bytecode, a list of OpCodes.
    pub code: IndexVec<CodeId, OpCode<CodeId>>,

    /// List of constants used in the bytecode.
    pub consts: IndexVec<ConstId, ConstValue<S, ConstCodeId>>,
    /// List of const function codes.
    pub const_codes: IndexVec<ConstCodeId, Rc<Code<S>>>,
    /// List of local names.
    pub local_names: IndexVec<LocalNameId, S>,
    /// List of global names.
    pub global_names: IndexVec<GlobalNameId, S>,
    /// List of Upvalue information.
    pub upvalue_names: IndexVec<UpvalueNameId, (S, UpvalueCapture)>,

    /// The required virtual machine stack space.
    pub stack_size: usize,
}

impl<S: fmt::Display> fmt::Display for Code<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        if let Some(name) = &self.name {
            writeln!(f, "name: {name}")?;
        }
        writeln!(f, "params: ({})", self.params)?;
        writeln!(f, "kind: {}", self.kind)?;
        writeln!(f, "stack_size: {}", self.stack_size)?;
        writeln!(f, "consts: {}", self.consts.iter().join(", "))?;
        writeln!(f, "local_names: {}", self.local_names.iter().join(", "))?;
        writeln!(f, "global_names: {}", self.global_names.iter().join(", "))?;
        writeln!(
            f,
            "upvalue_names: {}",
            self.upvalue_names
                .iter()
                .map(|(name, base_closure_upvalue_id)| {
                    format!("({name}, {base_closure_upvalue_id:?})")
                })
                .join(", ")
        )?;
        #[expect(clippy::wildcard_enum_match_arm)]
        let code_str = self
            .code
            .iter()
            .enumerate()
            .map(|(index, code)| {
                format!(
                    "{index:>12} {code}{}",
                    match code {
                        OpCode::LoadLocal(i) | OpCode::StoreLocal(i) =>
                            format!(" ({})", self.local_names[*i]),
                        OpCode::LoadGlobal(i) | OpCode::StoreGlobal(i) =>
                            format!(" ({})", self.global_names[*i]),
                        OpCode::LoadUpvalue(i) => {
                            let (name, base_closure_upvalue_id) = &self.upvalue_names[*i];
                            format!(" ({name}, {base_closure_upvalue_id:?})")
                        }
                        OpCode::LoadConst(i) | OpCode::Import(i) | OpCode::ImportFrom(i) =>
                            format!(" ({})", self.consts[*i]),
                        _ => String::new(),
                    }
                )
            })
            .join("\n");
        write!(f, "code:\n{code_str}")
    }
}

/// The const value.
#[derive(Debug, Clone, PartialEq, Eq, Hash, From)]
pub enum ConstValue<S, F> {
    /// "null"
    Null,
    /// "true", "false"
    Bool(bool),
    /// "12", "0o100", "0b110"
    Int(i64),
    /// "12.34", "0b100.100"
    Float(Float),
    /// ""abc"", ""abc"
    #[from(skip)]
    Str(S),
    /// "b"abc""
    Bytes(Vec<u8>),
    /// A function code.
    #[from(skip)]
    Function(F),
    /// An effect.
    #[from(skip)]
    Effect(EffectConst<S>),
}

impl<S, F> ConstValue<S, F> {
    pub const fn value_type(&self) -> ValueType {
        match self {
            ConstValue::Null => ValueType::Null,
            ConstValue::Bool(_) => ValueType::Bool,
            ConstValue::Int(_) => ValueType::Int,
            ConstValue::Float(_) => ValueType::Float,
            ConstValue::Str(_) => ValueType::Str,
            ConstValue::Bytes(_) => ValueType::Bytes,
            ConstValue::Function(_) => ValueType::Function,
            ConstValue::Effect(_) => ValueType::Effect,
        }
    }
}

impl<S: fmt::Display, F: fmt::Display> fmt::Display for ConstValue<S, F> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ConstValue::Null => write!(f, "null"),
            ConstValue::Bool(v) => write!(f, "{v}"),
            ConstValue::Int(v) => write!(f, "{v}"),
            ConstValue::Float(v) => write!(f, "{v}"),
            ConstValue::Str(v) => write!(f, "{v}"),
            ConstValue::Bytes(v) => write!(f, "b\"{}\"", v.escape_ascii()),
            ConstValue::Function(v) => write!(f, "<code {v}>"),
            ConstValue::Effect(v) => write!(f, "{v}"),
        }
    }
}

impl<T, S, F> From<T> for ConstValue<S, F>
where
    T: Into<EffectConst<S>>,
{
    fn from(value: T) -> Self {
        ConstValue::Effect(value.into())
    }
}

/// The effect const value.
#[derive(Debug, Clone, PartialEq, Eq, Hash, From)]
pub enum EffectConst<S> {
    User(Rc<UserEffect<S>>),
    Builtin(BuiltinEffect),
}

impl<S: fmt::Display> fmt::Display for EffectConst<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            EffectConst::User(v) => write!(f, "{v}"),
            EffectConst::Builtin(v) => write!(f, "effect {}(...)", v.name()),
        }
    }
}

/// The user effect const value.
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UserEffect<S> {
    /// The effect name.
    pub name: S,
    /// Effect parameters.
    pub params: CodeParams<S>,
}

impl<S: fmt::Display> fmt::Display for UserEffect<S> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "effect {}({})", self.name, self.params)
    }
}
